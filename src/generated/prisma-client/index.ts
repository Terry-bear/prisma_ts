// Code generated by Prisma (prisma@1.26.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  accessKey: (where?: AccessKeyWhereInput) => Promise<boolean>;
  account: (where?: AccountWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  jwtRsa: (where?: JwtRsaWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  serviceRole: (where?: ServiceRoleWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accessKey: (where: AccessKeyWhereUniqueInput) => AccessKeyPromise;
  accessKeys: (args?: {
    where?: AccessKeyWhereInput;
    orderBy?: AccessKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AccessKey>;
  accessKeysConnection: (args?: {
    where?: AccessKeyWhereInput;
    orderBy?: AccessKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccessKeyConnectionPromise;
  account: (where: AccountWhereUniqueInput) => AccountPromise;
  accounts: (args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Account>;
  accountsConnection: (args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccountConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupPromise;
  groups: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Group>;
  groupsConnection: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupConnectionPromise;
  jwtRsa: (where: JwtRsaWhereUniqueInput) => JwtRsaPromise;
  jwtRsas: (args?: {
    where?: JwtRsaWhereInput;
    orderBy?: JwtRsaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<JwtRsa>;
  jwtRsasConnection: (args?: {
    where?: JwtRsaWhereInput;
    orderBy?: JwtRsaOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JwtRsaConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  permissions: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Permission>;
  permissionsConnection: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PermissionConnectionPromise;
  serviceRole: (where: ServiceRoleWhereUniqueInput) => ServiceRolePromise;
  serviceRoles: (args?: {
    where?: ServiceRoleWhereInput;
    orderBy?: ServiceRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ServiceRole>;
  serviceRolesConnection: (args?: {
    where?: ServiceRoleWhereInput;
    orderBy?: ServiceRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceRoleConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccessKey: (data: AccessKeyCreateInput) => AccessKeyPromise;
  updateAccessKey: (args: {
    data: AccessKeyUpdateInput;
    where: AccessKeyWhereUniqueInput;
  }) => AccessKeyPromise;
  updateManyAccessKeys: (args: {
    data: AccessKeyUpdateManyMutationInput;
    where?: AccessKeyWhereInput;
  }) => BatchPayloadPromise;
  upsertAccessKey: (args: {
    where: AccessKeyWhereUniqueInput;
    create: AccessKeyCreateInput;
    update: AccessKeyUpdateInput;
  }) => AccessKeyPromise;
  deleteAccessKey: (where: AccessKeyWhereUniqueInput) => AccessKeyPromise;
  deleteManyAccessKeys: (where?: AccessKeyWhereInput) => BatchPayloadPromise;
  createAccount: (data: AccountCreateInput) => AccountPromise;
  updateAccount: (args: {
    data: AccountUpdateInput;
    where: AccountWhereUniqueInput;
  }) => AccountPromise;
  updateManyAccounts: (args: {
    data: AccountUpdateManyMutationInput;
    where?: AccountWhereInput;
  }) => BatchPayloadPromise;
  upsertAccount: (args: {
    where: AccountWhereUniqueInput;
    create: AccountCreateInput;
    update: AccountUpdateInput;
  }) => AccountPromise;
  deleteAccount: (where: AccountWhereUniqueInput) => AccountPromise;
  deleteManyAccounts: (where?: AccountWhereInput) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (args: {
    data: GroupUpdateInput;
    where: GroupWhereUniqueInput;
  }) => GroupPromise;
  updateManyGroups: (args: {
    data: GroupUpdateManyMutationInput;
    where?: GroupWhereInput;
  }) => BatchPayloadPromise;
  upsertGroup: (args: {
    where: GroupWhereUniqueInput;
    create: GroupCreateInput;
    update: GroupUpdateInput;
  }) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createJwtRsa: (data: JwtRsaCreateInput) => JwtRsaPromise;
  updateJwtRsa: (args: {
    data: JwtRsaUpdateInput;
    where: JwtRsaWhereUniqueInput;
  }) => JwtRsaPromise;
  updateManyJwtRsas: (args: {
    data: JwtRsaUpdateManyMutationInput;
    where?: JwtRsaWhereInput;
  }) => BatchPayloadPromise;
  upsertJwtRsa: (args: {
    where: JwtRsaWhereUniqueInput;
    create: JwtRsaCreateInput;
    update: JwtRsaUpdateInput;
  }) => JwtRsaPromise;
  deleteJwtRsa: (where: JwtRsaWhereUniqueInput) => JwtRsaPromise;
  deleteManyJwtRsas: (where?: JwtRsaWhereInput) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (args: {
    data: PermissionUpdateInput;
    where: PermissionWhereUniqueInput;
  }) => PermissionPromise;
  updateManyPermissions: (args: {
    data: PermissionUpdateManyMutationInput;
    where?: PermissionWhereInput;
  }) => BatchPayloadPromise;
  upsertPermission: (args: {
    where: PermissionWhereUniqueInput;
    create: PermissionCreateInput;
    update: PermissionUpdateInput;
  }) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createServiceRole: (data: ServiceRoleCreateInput) => ServiceRolePromise;
  updateServiceRole: (args: {
    data: ServiceRoleUpdateInput;
    where: ServiceRoleWhereUniqueInput;
  }) => ServiceRolePromise;
  updateManyServiceRoles: (args: {
    data: ServiceRoleUpdateManyMutationInput;
    where?: ServiceRoleWhereInput;
  }) => BatchPayloadPromise;
  upsertServiceRole: (args: {
    where: ServiceRoleWhereUniqueInput;
    create: ServiceRoleCreateInput;
    update: ServiceRoleUpdateInput;
  }) => ServiceRolePromise;
  deleteServiceRole: (where: ServiceRoleWhereUniqueInput) => ServiceRolePromise;
  deleteManyServiceRoles: (
    where?: ServiceRoleWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accessKey: (
    where?: AccessKeySubscriptionWhereInput
  ) => AccessKeySubscriptionPayloadSubscription;
  account: (
    where?: AccountSubscriptionWhereInput
  ) => AccountSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  jwtRsa: (
    where?: JwtRsaSubscriptionWhereInput
  ) => JwtRsaSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  serviceRole: (
    where?: ServiceRoleSubscriptionWhereInput
  ) => ServiceRoleSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type GroupType = "USERGROUP" | "BUSINESSGROUP";

export type PermissionType = "SYSTEM" | "CUSTOM";

export type AccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userName_ASC"
  | "userName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "mobileNo_ASC"
  | "mobileNo_DESC"
  | "idCard_ASC"
  | "idCard_DESC"
  | "name_ASC"
  | "name_DESC"
  | "headpic_ASC"
  | "headpic_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetPasswordNext_ASC"
  | "resetPasswordNext_DESC"
  | "enable_ASC"
  | "enable_DESC"
  | "lastLoginAt_ASC"
  | "lastLoginAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type AccessKeyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "activated_ASC"
  | "activated_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type PermissionOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "remark_ASC"
  | "remark_DESC"
  | "type_ASC"
  | "type_DESC"
  | "usedCount_ASC"
  | "usedCount_DESC"
  | "currentVersion_ASC"
  | "currentVersion_DESC"
  | "version1Content_ASC"
  | "version1Content_DESC"
  | "version2Content_ASC"
  | "version2Content_DESC"
  | "version3Content_ASC"
  | "version3Content_DESC"
  | "version4Content_ASC"
  | "version4Content_DESC"
  | "version5Content_ASC"
  | "version5Content_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC";

export type JwtRsaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "publicKey_ASC"
  | "publicKey_DESC"
  | "privateKey_ASC"
  | "privateKey_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ServiceRoleOrderByInput =
  | "tenantIdServiceName_ASC"
  | "tenantIdServiceName_DESC"
  | "keyAuthSecret_ASC"
  | "keyAuthSecret_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface AccessKeyUpdateWithWhereUniqueWithoutAccountInput {
  where: AccessKeyWhereUniqueInput;
  data: AccessKeyUpdateWithoutAccountDataInput;
}

export type AccessKeyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  secret?: String;
}>;

export interface GroupUpdateManyWithoutAccountsInput {
  create?: GroupCreateWithoutAccountsInput[] | GroupCreateWithoutAccountsInput;
  delete?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  set?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  disconnect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  update?:
    | GroupUpdateWithWhereUniqueWithoutAccountsInput[]
    | GroupUpdateWithWhereUniqueWithoutAccountsInput;
  upsert?:
    | GroupUpsertWithWhereUniqueWithoutAccountsInput[]
    | GroupUpsertWithWhereUniqueWithoutAccountsInput;
  deleteMany?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  updateMany?:
    | GroupUpdateManyWithWhereNestedInput[]
    | GroupUpdateManyWithWhereNestedInput;
}

export interface PermissionWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  remark?: String;
  remark_not?: String;
  remark_in?: String[] | String;
  remark_not_in?: String[] | String;
  remark_lt?: String;
  remark_lte?: String;
  remark_gt?: String;
  remark_gte?: String;
  remark_contains?: String;
  remark_not_contains?: String;
  remark_starts_with?: String;
  remark_not_starts_with?: String;
  remark_ends_with?: String;
  remark_not_ends_with?: String;
  type?: PermissionType;
  type_not?: PermissionType;
  type_in?: PermissionType[] | PermissionType;
  type_not_in?: PermissionType[] | PermissionType;
  usedCount?: Int;
  usedCount_not?: Int;
  usedCount_in?: Int[] | Int;
  usedCount_not_in?: Int[] | Int;
  usedCount_lt?: Int;
  usedCount_lte?: Int;
  usedCount_gt?: Int;
  usedCount_gte?: Int;
  currentVersion?: Int;
  currentVersion_not?: Int;
  currentVersion_in?: Int[] | Int;
  currentVersion_not_in?: Int[] | Int;
  currentVersion_lt?: Int;
  currentVersion_lte?: Int;
  currentVersion_gt?: Int;
  currentVersion_gte?: Int;
  version1Content?: String;
  version1Content_not?: String;
  version1Content_in?: String[] | String;
  version1Content_not_in?: String[] | String;
  version1Content_lt?: String;
  version1Content_lte?: String;
  version1Content_gt?: String;
  version1Content_gte?: String;
  version1Content_contains?: String;
  version1Content_not_contains?: String;
  version1Content_starts_with?: String;
  version1Content_not_starts_with?: String;
  version1Content_ends_with?: String;
  version1Content_not_ends_with?: String;
  version2Content?: String;
  version2Content_not?: String;
  version2Content_in?: String[] | String;
  version2Content_not_in?: String[] | String;
  version2Content_lt?: String;
  version2Content_lte?: String;
  version2Content_gt?: String;
  version2Content_gte?: String;
  version2Content_contains?: String;
  version2Content_not_contains?: String;
  version2Content_starts_with?: String;
  version2Content_not_starts_with?: String;
  version2Content_ends_with?: String;
  version2Content_not_ends_with?: String;
  version3Content?: String;
  version3Content_not?: String;
  version3Content_in?: String[] | String;
  version3Content_not_in?: String[] | String;
  version3Content_lt?: String;
  version3Content_lte?: String;
  version3Content_gt?: String;
  version3Content_gte?: String;
  version3Content_contains?: String;
  version3Content_not_contains?: String;
  version3Content_starts_with?: String;
  version3Content_not_starts_with?: String;
  version3Content_ends_with?: String;
  version3Content_not_ends_with?: String;
  version4Content?: String;
  version4Content_not?: String;
  version4Content_in?: String[] | String;
  version4Content_not_in?: String[] | String;
  version4Content_lt?: String;
  version4Content_lte?: String;
  version4Content_gt?: String;
  version4Content_gte?: String;
  version4Content_contains?: String;
  version4Content_not_contains?: String;
  version4Content_starts_with?: String;
  version4Content_not_starts_with?: String;
  version4Content_ends_with?: String;
  version4Content_not_ends_with?: String;
  version5Content?: String;
  version5Content_not?: String;
  version5Content_in?: String[] | String;
  version5Content_not_in?: String[] | String;
  version5Content_lt?: String;
  version5Content_lte?: String;
  version5Content_gt?: String;
  version5Content_gte?: String;
  version5Content_contains?: String;
  version5Content_not_contains?: String;
  version5Content_starts_with?: String;
  version5Content_not_starts_with?: String;
  version5Content_ends_with?: String;
  version5Content_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: PermissionWhereInput[] | PermissionWhereInput;
  OR?: PermissionWhereInput[] | PermissionWhereInput;
  NOT?: PermissionWhereInput[] | PermissionWhereInput;
}

export interface AccessKeyCreateManyWithoutAccountInput {
  create?:
    | AccessKeyCreateWithoutAccountInput[]
    | AccessKeyCreateWithoutAccountInput;
  connect?: AccessKeyWhereUniqueInput[] | AccessKeyWhereUniqueInput;
}

export interface AccountUpdateManyDataInput {
  userName?: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password?: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  lastLoginAt?: DateTimeInput;
}

export interface AccessKeyCreateWithoutAccountInput {
  secret?: String;
  activated?: Boolean;
}

export interface GroupUpdateWithWhereUniqueWithoutAccountsInput {
  where: GroupWhereUniqueInput;
  data: GroupUpdateWithoutAccountsDataInput;
}

export interface GroupCreateManyWithoutAccountsInput {
  create?: GroupCreateWithoutAccountsInput[] | GroupCreateWithoutAccountsInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
}

export interface AccountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  mobileNo?: String;
  mobileNo_not?: String;
  mobileNo_in?: String[] | String;
  mobileNo_not_in?: String[] | String;
  mobileNo_lt?: String;
  mobileNo_lte?: String;
  mobileNo_gt?: String;
  mobileNo_gte?: String;
  mobileNo_contains?: String;
  mobileNo_not_contains?: String;
  mobileNo_starts_with?: String;
  mobileNo_not_starts_with?: String;
  mobileNo_ends_with?: String;
  mobileNo_not_ends_with?: String;
  idCard?: String;
  idCard_not?: String;
  idCard_in?: String[] | String;
  idCard_not_in?: String[] | String;
  idCard_lt?: String;
  idCard_lte?: String;
  idCard_gt?: String;
  idCard_gte?: String;
  idCard_contains?: String;
  idCard_not_contains?: String;
  idCard_starts_with?: String;
  idCard_not_starts_with?: String;
  idCard_ends_with?: String;
  idCard_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  headpic?: String;
  headpic_not?: String;
  headpic_in?: String[] | String;
  headpic_not_in?: String[] | String;
  headpic_lt?: String;
  headpic_lte?: String;
  headpic_gt?: String;
  headpic_gte?: String;
  headpic_contains?: String;
  headpic_not_contains?: String;
  headpic_starts_with?: String;
  headpic_not_starts_with?: String;
  headpic_ends_with?: String;
  headpic_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  resetPasswordNext?: Boolean;
  resetPasswordNext_not?: Boolean;
  enable?: Boolean;
  enable_not?: Boolean;
  parentAccount?: AccountWhereInput;
  subAccount_every?: AccountWhereInput;
  subAccount_some?: AccountWhereInput;
  subAccount_none?: AccountWhereInput;
  accessKeys_every?: AccessKeyWhereInput;
  accessKeys_some?: AccessKeyWhereInput;
  accessKeys_none?: AccessKeyWhereInput;
  groups_every?: GroupWhereInput;
  groups_some?: GroupWhereInput;
  groups_none?: GroupWhereInput;
  permissions_every?: PermissionWhereInput;
  permissions_some?: PermissionWhereInput;
  permissions_none?: PermissionWhereInput;
  lastLoginAt?: DateTimeInput;
  lastLoginAt_not?: DateTimeInput;
  lastLoginAt_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_not_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_lt?: DateTimeInput;
  lastLoginAt_lte?: DateTimeInput;
  lastLoginAt_gt?: DateTimeInput;
  lastLoginAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: AccountWhereInput[] | AccountWhereInput;
  OR?: AccountWhereInput[] | AccountWhereInput;
  NOT?: AccountWhereInput[] | AccountWhereInput;
}

export interface GroupCreateWithoutAccountsInput {
  type?: GroupType;
  permissions?: PermissionCreateManyInput;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PermissionWhereInput;
  AND?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  OR?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  NOT?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
}

export interface PermissionCreateManyInput {
  create?: PermissionCreateInput[] | PermissionCreateInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GroupWhereInput;
  AND?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  OR?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  NOT?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
}

export interface PermissionCreateInput {
  name: String;
  remark: String;
  type?: PermissionType;
  usedCount?: Int;
  currentVersion: Int;
  version1Content?: String;
  version2Content?: String;
  version3Content?: String;
  version4Content?: String;
  version5Content?: String;
}

export interface AccessKeySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccessKeyWhereInput;
  AND?: AccessKeySubscriptionWhereInput[] | AccessKeySubscriptionWhereInput;
  OR?: AccessKeySubscriptionWhereInput[] | AccessKeySubscriptionWhereInput;
  NOT?: AccessKeySubscriptionWhereInput[] | AccessKeySubscriptionWhereInput;
}

export interface AccountCreateManyWithoutParentAccountInput {
  create?:
    | AccountCreateWithoutParentAccountInput[]
    | AccountCreateWithoutParentAccountInput;
  connect?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
}

export type AccountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  userName?: String;
  email?: String;
  idCard?: String;
}>;

export interface AccountCreateWithoutParentAccountInput {
  userName: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  subAccount?: AccountCreateManyWithoutParentAccountInput;
  accessKeys?: AccessKeyCreateManyWithoutAccountInput;
  groups?: GroupCreateManyWithoutAccountsInput;
  permissions?: PermissionCreateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface ServiceRoleCreateInput {
  tenantIdServiceName: String;
  keyAuthSecret: String;
  permissions?: PermissionCreateManyInput;
}

export interface AccessKeyUpdateInput {
  secret?: String;
  activated?: Boolean;
  account?: AccountUpdateOneRequiredWithoutAccessKeysInput;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AccountUpdateOneRequiredWithoutAccessKeysInput {
  create?: AccountCreateWithoutAccessKeysInput;
  update?: AccountUpdateWithoutAccessKeysDataInput;
  upsert?: AccountUpsertWithoutAccessKeysInput;
  connect?: AccountWhereUniqueInput;
}

export interface JwtRsaUpdateManyMutationInput {
  publicKey?: String;
  privateKey?: String;
}

export interface AccountUpdateWithoutAccessKeysDataInput {
  userName?: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password?: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountUpdateOneWithoutSubAccountInput;
  subAccount?: AccountUpdateManyWithoutParentAccountInput;
  groups?: GroupUpdateManyWithoutAccountsInput;
  permissions?: PermissionUpdateManyInput;
  lastLoginAt?: DateTimeInput;
}

export type JwtRsaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AccountUpdateOneWithoutSubAccountInput {
  create?: AccountCreateWithoutSubAccountInput;
  update?: AccountUpdateWithoutSubAccountDataInput;
  upsert?: AccountUpsertWithoutSubAccountInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AccountWhereUniqueInput;
}

export interface JwtRsaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  publicKey?: String;
  publicKey_not?: String;
  publicKey_in?: String[] | String;
  publicKey_not_in?: String[] | String;
  publicKey_lt?: String;
  publicKey_lte?: String;
  publicKey_gt?: String;
  publicKey_gte?: String;
  publicKey_contains?: String;
  publicKey_not_contains?: String;
  publicKey_starts_with?: String;
  publicKey_not_starts_with?: String;
  publicKey_ends_with?: String;
  publicKey_not_ends_with?: String;
  privateKey?: String;
  privateKey_not?: String;
  privateKey_in?: String[] | String;
  privateKey_not_in?: String[] | String;
  privateKey_lt?: String;
  privateKey_lte?: String;
  privateKey_gt?: String;
  privateKey_gte?: String;
  privateKey_contains?: String;
  privateKey_not_contains?: String;
  privateKey_starts_with?: String;
  privateKey_not_starts_with?: String;
  privateKey_ends_with?: String;
  privateKey_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: JwtRsaWhereInput[] | JwtRsaWhereInput;
  OR?: JwtRsaWhereInput[] | JwtRsaWhereInput;
  NOT?: JwtRsaWhereInput[] | JwtRsaWhereInput;
}

export interface AccountUpdateWithoutSubAccountDataInput {
  userName?: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password?: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountUpdateOneWithoutSubAccountInput;
  accessKeys?: AccessKeyUpdateManyWithoutAccountInput;
  groups?: GroupUpdateManyWithoutAccountsInput;
  permissions?: PermissionUpdateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface AccountUpsertWithWhereUniqueWithoutGroupsInput {
  where: AccountWhereUniqueInput;
  update: AccountUpdateWithoutGroupsDataInput;
  create: AccountCreateWithoutGroupsInput;
}

export interface AccessKeyUpdateManyWithoutAccountInput {
  create?:
    | AccessKeyCreateWithoutAccountInput[]
    | AccessKeyCreateWithoutAccountInput;
  delete?: AccessKeyWhereUniqueInput[] | AccessKeyWhereUniqueInput;
  connect?: AccessKeyWhereUniqueInput[] | AccessKeyWhereUniqueInput;
  set?: AccessKeyWhereUniqueInput[] | AccessKeyWhereUniqueInput;
  disconnect?: AccessKeyWhereUniqueInput[] | AccessKeyWhereUniqueInput;
  update?:
    | AccessKeyUpdateWithWhereUniqueWithoutAccountInput[]
    | AccessKeyUpdateWithWhereUniqueWithoutAccountInput;
  upsert?:
    | AccessKeyUpsertWithWhereUniqueWithoutAccountInput[]
    | AccessKeyUpsertWithWhereUniqueWithoutAccountInput;
  deleteMany?: AccessKeyScalarWhereInput[] | AccessKeyScalarWhereInput;
  updateMany?:
    | AccessKeyUpdateManyWithWhereNestedInput[]
    | AccessKeyUpdateManyWithWhereNestedInput;
}

export interface AccountUpdateWithWhereUniqueWithoutGroupsInput {
  where: AccountWhereUniqueInput;
  data: AccountUpdateWithoutGroupsDataInput;
}

export interface AccessKeyUpdateManyMutationInput {
  secret?: String;
  activated?: Boolean;
}

export interface AccountUpdateManyWithoutGroupsInput {
  create?: AccountCreateWithoutGroupsInput[] | AccountCreateWithoutGroupsInput;
  delete?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  connect?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  set?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  disconnect?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  update?:
    | AccountUpdateWithWhereUniqueWithoutGroupsInput[]
    | AccountUpdateWithWhereUniqueWithoutGroupsInput;
  upsert?:
    | AccountUpsertWithWhereUniqueWithoutGroupsInput[]
    | AccountUpsertWithWhereUniqueWithoutGroupsInput;
  deleteMany?: AccountScalarWhereInput[] | AccountScalarWhereInput;
  updateMany?:
    | AccountUpdateManyWithWhereNestedInput[]
    | AccountUpdateManyWithWhereNestedInput;
}

export interface AccessKeyUpdateWithoutAccountDataInput {
  secret?: String;
  activated?: Boolean;
}

export interface AccountCreateWithoutGroupsInput {
  userName: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountCreateOneWithoutSubAccountInput;
  subAccount?: AccountCreateManyWithoutParentAccountInput;
  accessKeys?: AccessKeyCreateManyWithoutAccountInput;
  permissions?: PermissionCreateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface AccessKeyUpsertWithWhereUniqueWithoutAccountInput {
  where: AccessKeyWhereUniqueInput;
  update: AccessKeyUpdateWithoutAccountDataInput;
  create: AccessKeyCreateWithoutAccountInput;
}

export interface AccountCreateManyWithoutGroupsInput {
  create?: AccountCreateWithoutGroupsInput[] | AccountCreateWithoutGroupsInput;
  connect?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
}

export interface AccessKeyScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  secret?: String;
  secret_not?: String;
  secret_in?: String[] | String;
  secret_not_in?: String[] | String;
  secret_lt?: String;
  secret_lte?: String;
  secret_gt?: String;
  secret_gte?: String;
  secret_contains?: String;
  secret_not_contains?: String;
  secret_starts_with?: String;
  secret_not_starts_with?: String;
  secret_ends_with?: String;
  secret_not_ends_with?: String;
  activated?: Boolean;
  activated_not?: Boolean;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: AccessKeyScalarWhereInput[] | AccessKeyScalarWhereInput;
  OR?: AccessKeyScalarWhereInput[] | AccessKeyScalarWhereInput;
  NOT?: AccessKeyScalarWhereInput[] | AccessKeyScalarWhereInput;
}

export interface GroupCreateInput {
  type?: GroupType;
  accounts?: AccountCreateManyWithoutGroupsInput;
  permissions?: PermissionCreateManyInput;
}

export interface AccessKeyUpdateManyWithWhereNestedInput {
  where: AccessKeyScalarWhereInput;
  data: AccessKeyUpdateManyDataInput;
}

export interface AccountUpdateInput {
  userName?: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password?: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountUpdateOneWithoutSubAccountInput;
  subAccount?: AccountUpdateManyWithoutParentAccountInput;
  accessKeys?: AccessKeyUpdateManyWithoutAccountInput;
  groups?: GroupUpdateManyWithoutAccountsInput;
  permissions?: PermissionUpdateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface AccessKeyUpdateManyDataInput {
  secret?: String;
  activated?: Boolean;
}

export interface AccountCreateOneWithoutAccessKeysInput {
  create?: AccountCreateWithoutAccessKeysInput;
  connect?: AccountWhereUniqueInput;
}

export interface GroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: GroupType;
  type_not?: GroupType;
  type_in?: GroupType[] | GroupType;
  type_not_in?: GroupType[] | GroupType;
  accounts_every?: AccountWhereInput;
  accounts_some?: AccountWhereInput;
  accounts_none?: AccountWhereInput;
  permissions_every?: PermissionWhereInput;
  permissions_some?: PermissionWhereInput;
  permissions_none?: PermissionWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: GroupWhereInput[] | GroupWhereInput;
  OR?: GroupWhereInput[] | GroupWhereInput;
  NOT?: GroupWhereInput[] | GroupWhereInput;
}

export interface AccountCreateOneWithoutSubAccountInput {
  create?: AccountCreateWithoutSubAccountInput;
  connect?: AccountWhereUniqueInput;
}

export interface AccountUpsertWithoutAccessKeysInput {
  update: AccountUpdateWithoutAccessKeysDataInput;
  create: AccountCreateWithoutAccessKeysInput;
}

export interface AccessKeyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  secret?: String;
  secret_not?: String;
  secret_in?: String[] | String;
  secret_not_in?: String[] | String;
  secret_lt?: String;
  secret_lte?: String;
  secret_gt?: String;
  secret_gte?: String;
  secret_contains?: String;
  secret_not_contains?: String;
  secret_starts_with?: String;
  secret_not_starts_with?: String;
  secret_ends_with?: String;
  secret_not_ends_with?: String;
  activated?: Boolean;
  activated_not?: Boolean;
  account?: AccountWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: AccessKeyWhereInput[] | AccessKeyWhereInput;
  OR?: AccessKeyWhereInput[] | AccessKeyWhereInput;
  NOT?: AccessKeyWhereInput[] | AccessKeyWhereInput;
}

export interface GroupUpdateWithoutAccountsDataInput {
  type?: GroupType;
  permissions?: PermissionUpdateManyInput;
}

export interface JwtRsaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JwtRsaWhereInput;
  AND?: JwtRsaSubscriptionWhereInput[] | JwtRsaSubscriptionWhereInput;
  OR?: JwtRsaSubscriptionWhereInput[] | JwtRsaSubscriptionWhereInput;
  NOT?: JwtRsaSubscriptionWhereInput[] | JwtRsaSubscriptionWhereInput;
}

export interface PermissionUpdateManyInput {
  create?: PermissionCreateInput[] | PermissionCreateInput;
  update?:
    | PermissionUpdateWithWhereUniqueNestedInput[]
    | PermissionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PermissionUpsertWithWhereUniqueNestedInput[]
    | PermissionUpsertWithWhereUniqueNestedInput;
  delete?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  set?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  disconnect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  deleteMany?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  updateMany?:
    | PermissionUpdateManyWithWhereNestedInput[]
    | PermissionUpdateManyWithWhereNestedInput;
}

export interface ServiceRoleUpdateManyMutationInput {
  tenantIdServiceName?: String;
  keyAuthSecret?: String;
}

export interface PermissionUpdateWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput;
  data: PermissionUpdateDataInput;
}

export interface PermissionUpdateManyMutationInput {
  name?: String;
  remark?: String;
  type?: PermissionType;
  usedCount?: Int;
  currentVersion?: Int;
  version1Content?: String;
  version2Content?: String;
  version3Content?: String;
  version4Content?: String;
  version5Content?: String;
}

export interface PermissionUpdateDataInput {
  name?: String;
  remark?: String;
  type?: PermissionType;
  usedCount?: Int;
  currentVersion?: Int;
  version1Content?: String;
  version2Content?: String;
  version3Content?: String;
  version4Content?: String;
  version5Content?: String;
}

export interface JwtRsaUpdateInput {
  publicKey?: String;
  privateKey?: String;
}

export interface PermissionUpsertWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput;
  update: PermissionUpdateDataInput;
  create: PermissionCreateInput;
}

export interface GroupUpdateManyMutationInput {
  type?: GroupType;
}

export interface PermissionScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  remark?: String;
  remark_not?: String;
  remark_in?: String[] | String;
  remark_not_in?: String[] | String;
  remark_lt?: String;
  remark_lte?: String;
  remark_gt?: String;
  remark_gte?: String;
  remark_contains?: String;
  remark_not_contains?: String;
  remark_starts_with?: String;
  remark_not_starts_with?: String;
  remark_ends_with?: String;
  remark_not_ends_with?: String;
  type?: PermissionType;
  type_not?: PermissionType;
  type_in?: PermissionType[] | PermissionType;
  type_not_in?: PermissionType[] | PermissionType;
  usedCount?: Int;
  usedCount_not?: Int;
  usedCount_in?: Int[] | Int;
  usedCount_not_in?: Int[] | Int;
  usedCount_lt?: Int;
  usedCount_lte?: Int;
  usedCount_gt?: Int;
  usedCount_gte?: Int;
  currentVersion?: Int;
  currentVersion_not?: Int;
  currentVersion_in?: Int[] | Int;
  currentVersion_not_in?: Int[] | Int;
  currentVersion_lt?: Int;
  currentVersion_lte?: Int;
  currentVersion_gt?: Int;
  currentVersion_gte?: Int;
  version1Content?: String;
  version1Content_not?: String;
  version1Content_in?: String[] | String;
  version1Content_not_in?: String[] | String;
  version1Content_lt?: String;
  version1Content_lte?: String;
  version1Content_gt?: String;
  version1Content_gte?: String;
  version1Content_contains?: String;
  version1Content_not_contains?: String;
  version1Content_starts_with?: String;
  version1Content_not_starts_with?: String;
  version1Content_ends_with?: String;
  version1Content_not_ends_with?: String;
  version2Content?: String;
  version2Content_not?: String;
  version2Content_in?: String[] | String;
  version2Content_not_in?: String[] | String;
  version2Content_lt?: String;
  version2Content_lte?: String;
  version2Content_gt?: String;
  version2Content_gte?: String;
  version2Content_contains?: String;
  version2Content_not_contains?: String;
  version2Content_starts_with?: String;
  version2Content_not_starts_with?: String;
  version2Content_ends_with?: String;
  version2Content_not_ends_with?: String;
  version3Content?: String;
  version3Content_not?: String;
  version3Content_in?: String[] | String;
  version3Content_not_in?: String[] | String;
  version3Content_lt?: String;
  version3Content_lte?: String;
  version3Content_gt?: String;
  version3Content_gte?: String;
  version3Content_contains?: String;
  version3Content_not_contains?: String;
  version3Content_starts_with?: String;
  version3Content_not_starts_with?: String;
  version3Content_ends_with?: String;
  version3Content_not_ends_with?: String;
  version4Content?: String;
  version4Content_not?: String;
  version4Content_in?: String[] | String;
  version4Content_not_in?: String[] | String;
  version4Content_lt?: String;
  version4Content_lte?: String;
  version4Content_gt?: String;
  version4Content_gte?: String;
  version4Content_contains?: String;
  version4Content_not_contains?: String;
  version4Content_starts_with?: String;
  version4Content_not_starts_with?: String;
  version4Content_ends_with?: String;
  version4Content_not_ends_with?: String;
  version5Content?: String;
  version5Content_not?: String;
  version5Content_in?: String[] | String;
  version5Content_not_in?: String[] | String;
  version5Content_lt?: String;
  version5Content_lte?: String;
  version5Content_gt?: String;
  version5Content_gte?: String;
  version5Content_contains?: String;
  version5Content_not_contains?: String;
  version5Content_starts_with?: String;
  version5Content_not_starts_with?: String;
  version5Content_ends_with?: String;
  version5Content_not_ends_with?: String;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  OR?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  NOT?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
}

export type PermissionWhereUniqueInput = AtLeastOne<{
  name: String;
}>;

export interface PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput;
  data: PermissionUpdateManyDataInput;
}

export type ServiceRoleWhereUniqueInput = AtLeastOne<{
  tenantIdServiceName: String;
  keyAuthSecret?: String;
}>;

export interface PermissionUpdateManyDataInput {
  name?: String;
  remark?: String;
  type?: PermissionType;
  usedCount?: Int;
  currentVersion?: Int;
  version1Content?: String;
  version2Content?: String;
  version3Content?: String;
  version4Content?: String;
  version5Content?: String;
}

export interface AccountUpdateManyMutationInput {
  userName?: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password?: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  lastLoginAt?: DateTimeInput;
}

export interface GroupUpsertWithWhereUniqueWithoutAccountsInput {
  where: GroupWhereUniqueInput;
  update: GroupUpdateWithoutAccountsDataInput;
  create: GroupCreateWithoutAccountsInput;
}

export interface AccessKeyCreateInput {
  secret?: String;
  activated?: Boolean;
  account: AccountCreateOneWithoutAccessKeysInput;
}

export interface GroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: GroupType;
  type_not?: GroupType;
  type_in?: GroupType[] | GroupType;
  type_not_in?: GroupType[] | GroupType;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  OR?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  NOT?: GroupScalarWhereInput[] | GroupScalarWhereInput;
}

export interface AccountCreateWithoutSubAccountInput {
  userName: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountCreateOneWithoutSubAccountInput;
  accessKeys?: AccessKeyCreateManyWithoutAccountInput;
  groups?: GroupCreateManyWithoutAccountsInput;
  permissions?: PermissionCreateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface GroupUpdateManyWithWhereNestedInput {
  where: GroupScalarWhereInput;
  data: GroupUpdateManyDataInput;
}

export interface AccountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccountWhereInput;
  AND?: AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput;
  OR?: AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput;
  NOT?: AccountSubscriptionWhereInput[] | AccountSubscriptionWhereInput;
}

export interface GroupUpdateManyDataInput {
  type?: GroupType;
}

export interface PermissionUpdateInput {
  name?: String;
  remark?: String;
  type?: PermissionType;
  usedCount?: Int;
  currentVersion?: Int;
  version1Content?: String;
  version2Content?: String;
  version3Content?: String;
  version4Content?: String;
  version5Content?: String;
}

export interface AccountUpsertWithoutSubAccountInput {
  update: AccountUpdateWithoutSubAccountDataInput;
  create: AccountCreateWithoutSubAccountInput;
}

export interface AccountUpdateWithoutGroupsDataInput {
  userName?: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password?: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountUpdateOneWithoutSubAccountInput;
  subAccount?: AccountUpdateManyWithoutParentAccountInput;
  accessKeys?: AccessKeyUpdateManyWithoutAccountInput;
  permissions?: PermissionUpdateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface AccountUpdateManyWithoutParentAccountInput {
  create?:
    | AccountCreateWithoutParentAccountInput[]
    | AccountCreateWithoutParentAccountInput;
  delete?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  connect?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  set?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  disconnect?: AccountWhereUniqueInput[] | AccountWhereUniqueInput;
  update?:
    | AccountUpdateWithWhereUniqueWithoutParentAccountInput[]
    | AccountUpdateWithWhereUniqueWithoutParentAccountInput;
  upsert?:
    | AccountUpsertWithWhereUniqueWithoutParentAccountInput[]
    | AccountUpsertWithWhereUniqueWithoutParentAccountInput;
  deleteMany?: AccountScalarWhereInput[] | AccountScalarWhereInput;
  updateMany?:
    | AccountUpdateManyWithWhereNestedInput[]
    | AccountUpdateManyWithWhereNestedInput;
}

export interface ServiceRoleWhereInput {
  tenantIdServiceName?: String;
  tenantIdServiceName_not?: String;
  tenantIdServiceName_in?: String[] | String;
  tenantIdServiceName_not_in?: String[] | String;
  tenantIdServiceName_lt?: String;
  tenantIdServiceName_lte?: String;
  tenantIdServiceName_gt?: String;
  tenantIdServiceName_gte?: String;
  tenantIdServiceName_contains?: String;
  tenantIdServiceName_not_contains?: String;
  tenantIdServiceName_starts_with?: String;
  tenantIdServiceName_not_starts_with?: String;
  tenantIdServiceName_ends_with?: String;
  tenantIdServiceName_not_ends_with?: String;
  keyAuthSecret?: String;
  keyAuthSecret_not?: String;
  keyAuthSecret_in?: String[] | String;
  keyAuthSecret_not_in?: String[] | String;
  keyAuthSecret_lt?: String;
  keyAuthSecret_lte?: String;
  keyAuthSecret_gt?: String;
  keyAuthSecret_gte?: String;
  keyAuthSecret_contains?: String;
  keyAuthSecret_not_contains?: String;
  keyAuthSecret_starts_with?: String;
  keyAuthSecret_not_starts_with?: String;
  keyAuthSecret_ends_with?: String;
  keyAuthSecret_not_ends_with?: String;
  permissions_every?: PermissionWhereInput;
  permissions_some?: PermissionWhereInput;
  permissions_none?: PermissionWhereInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: ServiceRoleWhereInput[] | ServiceRoleWhereInput;
  OR?: ServiceRoleWhereInput[] | ServiceRoleWhereInput;
  NOT?: ServiceRoleWhereInput[] | ServiceRoleWhereInput;
}

export interface AccountUpdateWithWhereUniqueWithoutParentAccountInput {
  where: AccountWhereUniqueInput;
  data: AccountUpdateWithoutParentAccountDataInput;
}

export interface AccountCreateWithoutAccessKeysInput {
  userName: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountCreateOneWithoutSubAccountInput;
  subAccount?: AccountCreateManyWithoutParentAccountInput;
  groups?: GroupCreateManyWithoutAccountsInput;
  permissions?: PermissionCreateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface AccountUpdateManyWithWhereNestedInput {
  where: AccountScalarWhereInput;
  data: AccountUpdateManyDataInput;
}

export interface AccountScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  userName?: String;
  userName_not?: String;
  userName_in?: String[] | String;
  userName_not_in?: String[] | String;
  userName_lt?: String;
  userName_lte?: String;
  userName_gt?: String;
  userName_gte?: String;
  userName_contains?: String;
  userName_not_contains?: String;
  userName_starts_with?: String;
  userName_not_starts_with?: String;
  userName_ends_with?: String;
  userName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  mobileNo?: String;
  mobileNo_not?: String;
  mobileNo_in?: String[] | String;
  mobileNo_not_in?: String[] | String;
  mobileNo_lt?: String;
  mobileNo_lte?: String;
  mobileNo_gt?: String;
  mobileNo_gte?: String;
  mobileNo_contains?: String;
  mobileNo_not_contains?: String;
  mobileNo_starts_with?: String;
  mobileNo_not_starts_with?: String;
  mobileNo_ends_with?: String;
  mobileNo_not_ends_with?: String;
  idCard?: String;
  idCard_not?: String;
  idCard_in?: String[] | String;
  idCard_not_in?: String[] | String;
  idCard_lt?: String;
  idCard_lte?: String;
  idCard_gt?: String;
  idCard_gte?: String;
  idCard_contains?: String;
  idCard_not_contains?: String;
  idCard_starts_with?: String;
  idCard_not_starts_with?: String;
  idCard_ends_with?: String;
  idCard_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  headpic?: String;
  headpic_not?: String;
  headpic_in?: String[] | String;
  headpic_not_in?: String[] | String;
  headpic_lt?: String;
  headpic_lte?: String;
  headpic_gt?: String;
  headpic_gte?: String;
  headpic_contains?: String;
  headpic_not_contains?: String;
  headpic_starts_with?: String;
  headpic_not_starts_with?: String;
  headpic_ends_with?: String;
  headpic_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  resetPasswordNext?: Boolean;
  resetPasswordNext_not?: Boolean;
  enable?: Boolean;
  enable_not?: Boolean;
  lastLoginAt?: DateTimeInput;
  lastLoginAt_not?: DateTimeInput;
  lastLoginAt_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_not_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_lt?: DateTimeInput;
  lastLoginAt_lte?: DateTimeInput;
  lastLoginAt_gt?: DateTimeInput;
  lastLoginAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: AccountScalarWhereInput[] | AccountScalarWhereInput;
  OR?: AccountScalarWhereInput[] | AccountScalarWhereInput;
  NOT?: AccountScalarWhereInput[] | AccountScalarWhereInput;
}

export interface AccountUpsertWithWhereUniqueWithoutParentAccountInput {
  where: AccountWhereUniqueInput;
  update: AccountUpdateWithoutParentAccountDataInput;
  create: AccountCreateWithoutParentAccountInput;
}

export interface AccountUpdateWithoutParentAccountDataInput {
  userName?: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password?: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  subAccount?: AccountUpdateManyWithoutParentAccountInput;
  accessKeys?: AccessKeyUpdateManyWithoutAccountInput;
  groups?: GroupUpdateManyWithoutAccountsInput;
  permissions?: PermissionUpdateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface ServiceRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ServiceRoleWhereInput;
  AND?: ServiceRoleSubscriptionWhereInput[] | ServiceRoleSubscriptionWhereInput;
  OR?: ServiceRoleSubscriptionWhereInput[] | ServiceRoleSubscriptionWhereInput;
  NOT?: ServiceRoleSubscriptionWhereInput[] | ServiceRoleSubscriptionWhereInput;
}

export interface AccountCreateInput {
  userName: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password: String;
  resetPasswordNext?: Boolean;
  enable?: Boolean;
  parentAccount?: AccountCreateOneWithoutSubAccountInput;
  subAccount?: AccountCreateManyWithoutParentAccountInput;
  accessKeys?: AccessKeyCreateManyWithoutAccountInput;
  groups?: GroupCreateManyWithoutAccountsInput;
  permissions?: PermissionCreateManyInput;
  lastLoginAt?: DateTimeInput;
}

export interface GroupUpdateInput {
  type?: GroupType;
  accounts?: AccountUpdateManyWithoutGroupsInput;
  permissions?: PermissionUpdateManyInput;
}

export interface JwtRsaCreateInput {
  publicKey?: String;
  privateKey?: String;
}

export interface ServiceRoleUpdateInput {
  tenantIdServiceName?: String;
  keyAuthSecret?: String;
  permissions?: PermissionUpdateManyInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ServiceRolePreviousValues {
  tenantIdServiceName: String;
  keyAuthSecret: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ServiceRolePreviousValuesPromise
  extends Promise<ServiceRolePreviousValues>,
    Fragmentable {
  tenantIdServiceName: () => Promise<String>;
  keyAuthSecret: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ServiceRolePreviousValuesSubscription
  extends Promise<AsyncIterator<ServiceRolePreviousValues>>,
    Fragmentable {
  tenantIdServiceName: () => Promise<AsyncIterator<String>>;
  keyAuthSecret: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface Account {
  id: ID_Output;
  userName: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password: String;
  resetPasswordNext: Boolean;
  enable: Boolean;
  lastLoginAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AccountPromise extends Promise<Account>, Fragmentable {
  id: () => Promise<ID_Output>;
  userName: () => Promise<String>;
  email: () => Promise<String>;
  mobileNo: () => Promise<String>;
  idCard: () => Promise<String>;
  name: () => Promise<String>;
  headpic: () => Promise<String>;
  password: () => Promise<String>;
  resetPasswordNext: () => Promise<Boolean>;
  enable: () => Promise<Boolean>;
  parentAccount: <T = AccountPromise>() => T;
  subAccount: <T = FragmentableArray<Account>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessKeys: <T = FragmentableArray<AccessKey>>(args?: {
    where?: AccessKeyWhereInput;
    orderBy?: AccessKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  groups: <T = FragmentableArray<Group>>(args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  permissions: <T = FragmentableArray<Permission>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastLoginAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AccountSubscription
  extends Promise<AsyncIterator<Account>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobileNo: () => Promise<AsyncIterator<String>>;
  idCard: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  headpic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetPasswordNext: () => Promise<AsyncIterator<Boolean>>;
  enable: () => Promise<AsyncIterator<Boolean>>;
  parentAccount: <T = AccountSubscription>() => T;
  subAccount: <T = Promise<AsyncIterator<AccountSubscription>>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  accessKeys: <T = Promise<AsyncIterator<AccessKeySubscription>>>(args?: {
    where?: AccessKeyWhereInput;
    orderBy?: AccessKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  groups: <T = Promise<AsyncIterator<GroupSubscription>>>(args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastLoginAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateAccount {
  count: Int;
}

export interface AggregateAccountPromise
  extends Promise<AggregateAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountSubscription
  extends Promise<AsyncIterator<AggregateAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccountEdge {
  node: Account;
  cursor: String;
}

export interface AccountEdgePromise extends Promise<AccountEdge>, Fragmentable {
  node: <T = AccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountEdgeSubscription
  extends Promise<AsyncIterator<AccountEdge>>,
    Fragmentable {
  node: <T = AccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PermissionPreviousValues {
  name: String;
  remark: String;
  type?: PermissionType;
  usedCount: Int;
  currentVersion: Int;
  version1Content?: String;
  version2Content?: String;
  version3Content?: String;
  version4Content?: String;
  version5Content?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  remark: () => Promise<String>;
  type: () => Promise<PermissionType>;
  usedCount: () => Promise<Int>;
  currentVersion: () => Promise<Int>;
  version1Content: () => Promise<String>;
  version2Content: () => Promise<String>;
  version3Content: () => Promise<String>;
  version4Content: () => Promise<String>;
  version5Content: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  remark: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<PermissionType>>;
  usedCount: () => Promise<AsyncIterator<Int>>;
  currentVersion: () => Promise<AsyncIterator<Int>>;
  version1Content: () => Promise<AsyncIterator<String>>;
  version2Content: () => Promise<AsyncIterator<String>>;
  version3Content: () => Promise<AsyncIterator<String>>;
  version4Content: () => Promise<AsyncIterator<String>>;
  version5Content: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ServiceRoleSubscriptionPayload {
  mutation: MutationType;
  node: ServiceRole;
  updatedFields: String[];
  previousValues: ServiceRolePreviousValues;
}

export interface ServiceRoleSubscriptionPayloadPromise
  extends Promise<ServiceRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServiceRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServiceRolePreviousValuesPromise>() => T;
}

export interface ServiceRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServiceRolePreviousValuesSubscription>() => T;
}

export interface AccountConnection {
  pageInfo: PageInfo;
  edges: AccountEdge[];
}

export interface AccountConnectionPromise
  extends Promise<AccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountEdge>>() => T;
  aggregate: <T = AggregateAccountPromise>() => T;
}

export interface AccountConnectionSubscription
  extends Promise<AsyncIterator<AccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccountSubscription>() => T;
}

export interface ServiceRoleEdge {
  node: ServiceRole;
  cursor: String;
}

export interface ServiceRoleEdgePromise
  extends Promise<ServiceRoleEdge>,
    Fragmentable {
  node: <T = ServiceRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceRoleEdgeSubscription
  extends Promise<AsyncIterator<ServiceRoleEdge>>,
    Fragmentable {
  node: <T = ServiceRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccessKey {
  count: Int;
}

export interface AggregateAccessKeyPromise
  extends Promise<AggregateAccessKey>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccessKeySubscription
  extends Promise<AsyncIterator<AggregateAccessKey>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccessKey {
  id: ID_Output;
  secret?: String;
  activated: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AccessKeyPromise extends Promise<AccessKey>, Fragmentable {
  id: () => Promise<ID_Output>;
  secret: () => Promise<String>;
  activated: () => Promise<Boolean>;
  account: <T = AccountPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AccessKeySubscription
  extends Promise<AsyncIterator<AccessKey>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  secret: () => Promise<AsyncIterator<String>>;
  activated: () => Promise<AsyncIterator<Boolean>>;
  account: <T = AccountSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AccessKeyEdge {
  node: AccessKey;
  cursor: String;
}

export interface AccessKeyEdgePromise
  extends Promise<AccessKeyEdge>,
    Fragmentable {
  node: <T = AccessKeyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccessKeyEdgeSubscription
  extends Promise<AsyncIterator<AccessKeyEdge>>,
    Fragmentable {
  node: <T = AccessKeySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  node: Permission;
  updatedFields: String[];
  previousValues: PermissionPreviousValues;
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValuesPromise>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface PermissionConnection {
  pageInfo: PageInfo;
  edges: PermissionEdge[];
}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermissionPromise>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface AccessKeySubscriptionPayload {
  mutation: MutationType;
  node: AccessKey;
  updatedFields: String[];
  previousValues: AccessKeyPreviousValues;
}

export interface AccessKeySubscriptionPayloadPromise
  extends Promise<AccessKeySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccessKeyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccessKeyPreviousValuesPromise>() => T;
}

export interface AccessKeySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccessKeySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccessKeySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccessKeyPreviousValuesSubscription>() => T;
}

export interface JwtRsaEdge {
  node: JwtRsa;
  cursor: String;
}

export interface JwtRsaEdgePromise extends Promise<JwtRsaEdge>, Fragmentable {
  node: <T = JwtRsaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JwtRsaEdgeSubscription
  extends Promise<AsyncIterator<JwtRsaEdge>>,
    Fragmentable {
  node: <T = JwtRsaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccessKeyPreviousValues {
  id: ID_Output;
  secret?: String;
  activated: Boolean;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AccessKeyPreviousValuesPromise
  extends Promise<AccessKeyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  secret: () => Promise<String>;
  activated: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AccessKeyPreviousValuesSubscription
  extends Promise<AsyncIterator<AccessKeyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  secret: () => Promise<AsyncIterator<String>>;
  activated: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Group {
  id: ID_Output;
  type?: GroupType;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<GroupType>;
  accounts: <T = FragmentableArray<Account>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  permissions: <T = FragmentableArray<Permission>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<GroupType>>;
  accounts: <T = Promise<AsyncIterator<AccountSubscription>>>(args?: {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccountSubscriptionPayload {
  mutation: MutationType;
  node: Account;
  updatedFields: String[];
  previousValues: AccountPreviousValues;
}

export interface AccountSubscriptionPayloadPromise
  extends Promise<AccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountPreviousValuesPromise>() => T;
}

export interface AccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccountPreviousValues {
  id: ID_Output;
  userName: String;
  email?: String;
  mobileNo?: String;
  idCard?: String;
  name?: String;
  headpic?: String;
  password: String;
  resetPasswordNext: Boolean;
  enable: Boolean;
  lastLoginAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface AccountPreviousValuesPromise
  extends Promise<AccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userName: () => Promise<String>;
  email: () => Promise<String>;
  mobileNo: () => Promise<String>;
  idCard: () => Promise<String>;
  name: () => Promise<String>;
  headpic: () => Promise<String>;
  password: () => Promise<String>;
  resetPasswordNext: () => Promise<Boolean>;
  enable: () => Promise<Boolean>;
  lastLoginAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface AccountPreviousValuesSubscription
  extends Promise<AsyncIterator<AccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  mobileNo: () => Promise<AsyncIterator<String>>;
  idCard: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  headpic: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetPasswordNext: () => Promise<AsyncIterator<Boolean>>;
  enable: () => Promise<AsyncIterator<Boolean>>;
  lastLoginAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ServiceRoleConnection {
  pageInfo: PageInfo;
  edges: ServiceRoleEdge[];
}

export interface ServiceRoleConnectionPromise
  extends Promise<ServiceRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceRoleEdge>>() => T;
  aggregate: <T = AggregateServiceRolePromise>() => T;
}

export interface ServiceRoleConnectionSubscription
  extends Promise<AsyncIterator<ServiceRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceRoleSubscription>() => T;
}

export interface AccessKeyConnection {
  pageInfo: PageInfo;
  edges: AccessKeyEdge[];
}

export interface AccessKeyConnectionPromise
  extends Promise<AccessKeyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccessKeyEdge>>() => T;
  aggregate: <T = AggregateAccessKeyPromise>() => T;
}

export interface AccessKeyConnectionSubscription
  extends Promise<AsyncIterator<AccessKeyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccessKeyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccessKeySubscription>() => T;
}

export interface PermissionEdge {
  node: Permission;
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = PermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface JwtRsaConnection {
  pageInfo: PageInfo;
  edges: JwtRsaEdge[];
}

export interface JwtRsaConnectionPromise
  extends Promise<JwtRsaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JwtRsaEdge>>() => T;
  aggregate: <T = AggregateJwtRsaPromise>() => T;
}

export interface JwtRsaConnectionSubscription
  extends Promise<AsyncIterator<JwtRsaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JwtRsaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJwtRsaSubscription>() => T;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface JwtRsaPreviousValues {
  id: ID_Output;
  publicKey?: String;
  privateKey?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface JwtRsaPreviousValuesPromise
  extends Promise<JwtRsaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  publicKey: () => Promise<String>;
  privateKey: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface JwtRsaPreviousValuesSubscription
  extends Promise<AsyncIterator<JwtRsaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  publicKey: () => Promise<AsyncIterator<String>>;
  privateKey: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JwtRsaSubscriptionPayload {
  mutation: MutationType;
  node: JwtRsa;
  updatedFields: String[];
  previousValues: JwtRsaPreviousValues;
}

export interface JwtRsaSubscriptionPayloadPromise
  extends Promise<JwtRsaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JwtRsaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JwtRsaPreviousValuesPromise>() => T;
}

export interface JwtRsaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JwtRsaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JwtRsaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JwtRsaPreviousValuesSubscription>() => T;
}

export interface Permission {
  name: String;
  remark: String;
  type?: PermissionType;
  usedCount: Int;
  currentVersion: Int;
  version1Content?: String;
  version2Content?: String;
  version3Content?: String;
  version4Content?: String;
  version5Content?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  name: () => Promise<String>;
  remark: () => Promise<String>;
  type: () => Promise<PermissionType>;
  usedCount: () => Promise<Int>;
  currentVersion: () => Promise<Int>;
  version1Content: () => Promise<String>;
  version2Content: () => Promise<String>;
  version3Content: () => Promise<String>;
  version4Content: () => Promise<String>;
  version5Content: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  remark: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<PermissionType>>;
  usedCount: () => Promise<AsyncIterator<Int>>;
  currentVersion: () => Promise<AsyncIterator<Int>>;
  version1Content: () => Promise<AsyncIterator<String>>;
  version2Content: () => Promise<AsyncIterator<String>>;
  version3Content: () => Promise<AsyncIterator<String>>;
  version4Content: () => Promise<AsyncIterator<String>>;
  version5Content: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GroupPreviousValues {
  id: ID_Output;
  type?: GroupType;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<GroupType>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<GroupType>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateServiceRole {
  count: Int;
}

export interface AggregateServiceRolePromise
  extends Promise<AggregateServiceRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceRoleSubscription
  extends Promise<AsyncIterator<AggregateServiceRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JwtRsa {
  id: ID_Output;
  publicKey?: String;
  privateKey?: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface JwtRsaPromise extends Promise<JwtRsa>, Fragmentable {
  id: () => Promise<ID_Output>;
  publicKey: () => Promise<String>;
  privateKey: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface JwtRsaSubscription
  extends Promise<AsyncIterator<JwtRsa>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  publicKey: () => Promise<AsyncIterator<String>>;
  privateKey: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateJwtRsa {
  count: Int;
}

export interface AggregateJwtRsaPromise
  extends Promise<AggregateJwtRsa>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJwtRsaSubscription
  extends Promise<AsyncIterator<AggregateJwtRsa>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServiceRole {
  tenantIdServiceName: String;
  keyAuthSecret: String;
  updatedAt: DateTimeOutput;
  createdAt: DateTimeOutput;
}

export interface ServiceRolePromise extends Promise<ServiceRole>, Fragmentable {
  tenantIdServiceName: () => Promise<String>;
  keyAuthSecret: () => Promise<String>;
  permissions: <T = FragmentableArray<Permission>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ServiceRoleSubscription
  extends Promise<AsyncIterator<ServiceRole>>,
    Fragmentable {
  tenantIdServiceName: () => Promise<AsyncIterator<String>>;
  keyAuthSecret: () => Promise<AsyncIterator<String>>;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AccessKey",
    embedded: false
  },
  {
    name: "Account",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "GroupType",
    embedded: false
  },
  {
    name: "JwtRsa",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "PermissionType",
    embedded: false
  },
  {
    name: "ServiceRole",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_MANAGEMENT_API_SECRET"]}`
});
export const prisma = new Prisma();
